\documentclass[14pt,xcolor=dvipsnames]{beamer}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
%\usepackage[svgnames]{xcolor}
%\usetheme[secheader]{Boadilla}
%\usefonttheme{sans}
\setbeamersize{text margin left=1cm,text margin right=1cm}
\setbeamertemplate{section in toc}[Palo Alto]

\title{Die Burrows-Wheeler-Transformation}
\subtitle{Proseminar \glqq Algorithmen der Bioinformatik\grqq}
\author{Uli Köhler}
\date{12.~November 2012}

%Colors
\definecolor{darkgreen}{RGB}{0,110,29}

\setbeamertemplate{footline}
{%
%\begin{beamercolorbox}[wd=0.5\textwidth,ht=3ex,dp=1.5ex,leftskip=.5em,rightskip=.5em]{author in head/foot}%
%\usebeamerfont{author in head/foot}%
%\insertframenumber\hfill\insertshortauthor%
%\end{beamercolorbox}%
\vspace*{-4.5ex}\hspace*{0.5\textwidth}%
\begin{beamercolorbox}[width=\textwidth,ht=3ex,dp=1.5ex,left]{title in head/foot}%
\usebeamerfont{title in head/foot}%
Folie \insertframenumber{} von \inserttotalframenumber\hspace{8mm}
%\insertshorttitle%
\end{beamercolorbox}%
}

\AtBeginSection[]{} % for optional outline or other recurrent slide

\begin{document}
\frame{\titlepage}
\begin{frame}
\frametitle{Aufbau dieser Präsentation}
\tableofcontents
\end{frame}

\section{Grundlagen der Datenkompression}
\begin{frame}[allowframebreaks]
\frametitle{Große Datenmengen in der Bioinformatik}
  \begin{itemize}
   \item High-Throughput-Sequencing erzeugt durch \textit{n}-fache Abdeckung große Datenmengen
   \item Nur 4 Basen  sowie je nach Datensatz weitere \textit{k} Pseudobasen wie z.B \textit{X = nicht definiert}\\
   \textrightarrow\ Bei einer Speicherung als Text werden\\\quad\ nur $\frac{4+k}{256}$ jedes Bytes benutzt\\
   \textrightarrow\ Informationsgehalt einer DNA-Sequenz pro\\\quad\ Byte ist vergleichsweise gering
  \end{itemize}
\framebreak
\begin{itemize}
 \item Repeats (z.B. Satelliten) enthalten noch weniger Information pro Byte als eine zufällige DNA-Sequenz
 \item Idee der verlustfreien Kompression: Möglichst viel Information pro Byte durch Eliminierung von Redundanzen darstellen
 \item Anforderung: Ursprungstext muss sich ohne Veränderung wiederherstellen lassen
\end{itemize}

\end{frame}
%%%%%% Naive algorithm
\begin{frame}[allowframebreaks]
\frametitle{Ein naiver Kompressionsalgorithmus}
\begin{itemize}
 \item Eingabestring $S := AAAAAAAAATTT$ \textrightarrow $|S| = 12$
 \item Algorithmus fasst gleiche aufeinanderfolgende Zeichen zusammen
 \item Resultat: $S' = $ 9*A,3*T \textrightarrow $|S'|$ = 7
 \item Problem: Viele Strings (z.B. der STR ATATATAT) können nicht komprimiert werden
\end{itemize}
\framebreak
\begin{itemize}
 \item Beobachtung: Aufeinanderfolgende gleiche Zeichen können von diesem Algorithmus besser komprimiert werden
 \item Viele reale Kompressionsalgorithmen können davon ebenfalls profitieren\vspace{3mm}
 \item Ist es möglich, einen String reversibel so umzuordnen, dass möglichst viele gleiche Zeichen aufeinanderfolgen?\\
 \textrightarrow\ Burrows-Wheeler-Transformation
\end{itemize}
\end{frame}

\section{Burrows-Wheeler-Transformation}
%%%%%% 	
\subsection{Algorithmus der Burrows-Wheeler-Transformation}
\begin{frame}[allowframebreaks]
 \frametitle{BWT - Kompression}
    \begin{columns}[c,onlytextwidth]
    \column{0.55\textwidth}
    \begin{itemize}
	\item Eingabestring S: \textit{aabrac}
	\item Initialisierung einer Matrix M der Dimensionen $|S| \times |S|$
	\item Bildung aller zyklischen Rotationen des Eingabestrings
    \end{itemize}
    \column{0.45\textwidth}
    \begin{tabular}{c|c}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & aabrac \\
    1 & abraca \\
    2 & bracaa \\
    3 & racaab \\
    4 & acaabr \\
    5 & caabra \\
    \end{tabular}
    \end{columns}
\framebreak
%%%%%% Sorting
\begin{columns}[c,onlytextwidth]
 \column{.55\textwidth}
 \begin{itemize}
  \item Lexikographische Sortierung der Rotationen des Eingabestrings
 \end{itemize}
 \column{.45\textwidth}
    \begin{tabular}{c|c}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & aabrac \\
    1 & abraca \\
    2 & acaabr \\
    3 & bracaa \\
    4 & caabra \\
    5 & racaab \\
    \end{tabular}
\end{columns}
\framebreak
%%% Output of compression algorithm
\begin{columns}[c,onlytextwidth]
 \column{.55\textwidth}
 \begin{itemize}
  \item Resultat:\\
      Das Tupel \textit{$(L,I)$}, wobei L die {\color{red}letzte Spalte} der Matrix ist
      und I der Index des {\color{darkgreen}Eingabestrings in der Matrix} ist
  \item $(L,I) = (caraab, 1)$
 \end{itemize}
 \column{.45\textwidth}
    \begin{tabular}{c|c}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & aabra{\color{red}c} \\
    {\color{darkgreen}1} & {\color{darkgreen}abrac}{\color{red}a} \\
    2 & acaab{\color{red}r} \\
    3 & braca{\color{red}a} \\
    4 & caabr{\color{red}a} \\
    5 & racaa{\color{red}b} \\
    \end{tabular}
\end{columns}
\end{frame}
%%%%%% Decompression
\subsection{Inverse BWT}
\begin{frame}[allowframebreaks]
\frametitle{Idee der Rücktransformation}
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Eingabetupel: $(L,I)$
  \item Initialisierung einer Matrix M der Dimensionen $|L| \times |L|$
  \item Bereits bekannt: L ist die {\color{darkgreen}letzte Spalte} von M
 \end{itemize}
 \column{.35\textwidth}
    \begin{tabular}{c|c}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & \_\_\_\_\_{\color{darkgreen}c} \\
    1 & \_\_\_\_\_{\color{darkgreen}a} \\
    2 & \_\_\_\_\_{\color{darkgreen}r} \\
    3 & \_\_\_\_\_{\color{darkgreen}a} \\
    4 & \_\_\_\_\_{\color{darkgreen}a} \\
    5 & \_\_\_\_\_{\color{darkgreen}b} \\
    \end{tabular}
\end{columns}
\framebreak
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Die {\color{darkgreen}erste Spalte} ist immer sortiert
  \textrightarrow\ Kann durch sortieren von L ausgefüllt werden
 \end{itemize}

 \column{.35\textwidth}
    \begin{tabular}{c|l}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & {\color{darkgreen}a}\_\_\_\_c\\
    1 & {\color{darkgreen}a}\_\_\_\_a\\
    2 & {\color{darkgreen}a}\_\_\_\_r\\
    3 & {\color{darkgreen}b}\_\_\_\_a\\
    4 & {\color{darkgreen}c}\_\_\_\_a\\
    5 & {\color{darkgreen}r}\_\_\_\_b\\
    \end{tabular}
\end{columns}
\framebreak
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Die {\color{darkgreen}erste Spalte} ist immer sortiert
  \textrightarrow\ Kann durch sortieren von L ausgefüllt werden
 \end{itemize}

 \column{.35\textwidth}
    \begin{tabular}{c|l}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & {\color{darkgreen}a}\_\_\_\_c\\
    1 & {\color{darkgreen}a}\_\_\_\_a\\
    2 & {\color{darkgreen}a}\_\_\_\_r\\
    3 & {\color{darkgreen}b}\_\_\_\_a\\
    4 & {\color{darkgreen}c}\_\_\_\_a\\
    5 & {\color{darkgreen}r}\_\_\_\_b\\
    \end{tabular}
\end{columns}
\end{frame}
%%%%%% Problems and solutions
\subsection{Probleme der BWT}
\begin{frame}[allowframebreaks]
 \frametitle{Probleme der BWT}
 \begin{itemize}
  \item Komplexität der BWT ist $\mathcal{O}(n^2)$\\
    \textrightarrow \ Anwendung der BWT auf sehr große Datensätze (z.B. Genome) skaliert nicht
    \pause
  \item Lösung: Unterteilung des Datensatzes in kleinere \textit{Blöcke} - Anwendung der BWT auf diese Blöcke
 \end{itemize}
 
\framebreak
 \begin{itemize}
  \item Die Länge des Tupels $(L,I)$ ist insgesamt größer als Länge des Eingabestrings $|S|$
  \pause
  \item Lösung: Anwendung eines Kompressionsalgorithmus wie \textit{Deflate} auf $(L,I)$
  \end{itemize}
\end{frame}
%%%%%% Complexity
\begin{frame}
 \frametitle{Komplexität der BWT}
 \begin{itemize}
  \item Die Komplexität der BWT ist mindestens $\mathcal{O}(n^2)$
  % TODO 
 \end{itemize}
\end{frame}
\end{document}
