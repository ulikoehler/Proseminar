\documentclass[14pt,xcolor=dvipsnames,pdftex]{beamer}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{booktabs}
\usepackage{inconsolata} % TT font
\usepackage{array}
%\usepackage[svgnames]{xcolor}
%\usetheme[secheader]{Boadilla}
%\usefonttheme{sans}
\setbeamersize{text margin left=1cm,text margin right=1cm}
\setbeamertemplate{section in toc}[Palo Alto]

\newcolumntype{T}{c<{\ttfamily}}

\title{Die Burrows-Wheeler-Transformation}
\subtitle{Proseminar \glqq Algorithmen der Bioinformatik\grqq}
\author{Uli Köhler}
\date{12.~November 2012}

%Colors
\definecolor{darkgreen}{RGB}{0,110,29}

\setbeamertemplate{footline}
{%
%\begin{beamercolorbox}[wd=0.5\textwidth,ht=3ex,dp=1.5ex,leftskip=.5em,rightskip=.5em]{author in head/foot}%
%\usebeamerfont{author in head/foot}%
%\insertframenumber\hfill\insertshortauthor%
%\end{beamercolorbox}%
\vspace*{-4.5ex}\hspace*{0.5\textwidth}%
\begin{beamercolorbox}[width=\textwidth,ht=3ex,dp=1.5ex,left]{title in head/foot}%
\usebeamerfont{title in head/foot}%
Folie \insertframenumber{} von \inserttotalframenumber\hspace{8mm}
%\insertshorttitle%
\end{beamercolorbox}%
}

\AtBeginSection[]{} % for optional outline or other recurrent slide

\begin{document}
\frame{\titlepage}
\begin{frame}
\frametitle{Aufbau dieser Präsentation}
\tableofcontents
\end{frame}

\section{Grundlagen der Datenkompression}
\begin{frame}[allowframebreaks]
\frametitle{Große Datenmengen in der Bioinformatik}
  \begin{itemize}
   \item High-Throughput-Sequencing erzeugt durch \textit{n}-fache Abdeckung große Datenmengen
   \item Nur 4 Basen  sowie je nach Datensatz weitere \textit{k} Pseudobasen wie z.B \textit{X = nicht definiert}\\
   \textrightarrow\ Bei einer Speicherung als Text werden\\\quad\ nur $\frac{4+k}{256}$ jedes Bytes benutzt\\
   \textrightarrow\ Informationsgehalt einer DNA-Sequenz pro\\\quad\ Byte ist vergleichsweise gering
  \end{itemize}
\framebreak
\begin{itemize}
 \item Repeats (z.B. Satelliten) enthalten noch weniger Information pro Byte als eine zufällige DNA-Sequenz
\end{itemize}
\framebreak
\begin{itemize}
 \item \textbf{Lösung:} Verlustfreie Datenkompression\\
 \textrightarrow\ Daten unter Einsatz von weniger\\
 \quad\ Speicherplatz darstellen
 \item Anforderungen je nach Anwendung:
 \begin{itemize}
  \item Schnelle Kompression
  \item Geringe Größe der komprimierten Daten
  \item Schnelle Dekompression
  \item Geringe asymptotische Komplexität der Kompression/Dekompression
 \end{itemize}
\end{itemize}
\end{frame}
%%%%%% Compression
\begin{frame}[allowframebreaks]
 \frametitle{Kompression - Redundanzen}
 \begin{itemize}
  \item Ein Byte erlaubt die Darstellung von 256 verschiedenen Werten
  \item Die meisten Daten haben aber wesentlich kleinere Alphabete:
  \begin{itemize}
   \item Englischer Text: 26 Buchstaben + wenige Sonderzeichen (z.B. \textit{. , ( )})
   \item DNA: 4 Basen + Metainformationen
   \item Proteine: 20 Nukleinsäuren + Metainformationen
  \end{itemize}
 \end{itemize}
\end{frame}
%%%%%% Naive algorithm
\begin{frame}[allowframebreaks]
\frametitle{Ein naiver Kompressionsalgorithmus}
\begin{itemize}
 \item Eingabestring $S := AAAAAAAAATTT$ \textrightarrow $|S| = 12$
 \item Algorithmus fasst gleiche aufeinanderfolgende Zeichen zusammen
 \item Resultat: $S' = $ 9*A,3*T \textrightarrow $|S'|$ = 7
 \item Problem: Viele Strings (z.B. der STR ATATATAT) können nicht komprimiert werden
\end{itemize}
\framebreak
\begin{itemize}
 \item Beobachtung: Aufeinanderfolgende gleiche Zeichen können von diesem Algorithmus besser komprimiert werden
 \item Viele reale Kompressionsalgorithmen können davon ebenfalls profitieren\vspace{3mm}
 \item Ist es möglich, einen String reversibel so umzuordnen, dass möglichst viele gleiche Zeichen aufeinanderfolgen?\\
 \textrightarrow\ Burrows-Wheeler-Transformation
\end{itemize}
\end{frame}

\section{Burrows-Wheeler-Transformation}
%%%%%% 	
\subsection{Algorithmus der Burrows-Wheeler-Transformation}
\begin{frame}[allowframebreaks]
 \frametitle{BWT - Kompression}
    \begin{columns}[c,onlytextwidth]
    \column{0.55\textwidth}
    \begin{itemize}
	\item Eingabestring $S := \text{\texttt{aabrac}}$	
	\item Initialisierung einer Matrix M der Dimensionen $|S| \times |S|$
	\item Bildung aller zyklischen Rotationen des Eingabestrings
    \end{itemize}
    \column{0.45\textwidth}
    \begin{center}
    \begin{tabular}{T|T}
    0 & aabrac \\
    1 & abraca \\
    2 & bracaa \\
    3 & racaab \\
    4 & acaabr \\
    5 & caabra \\
    \end{tabular}
    \end{center}
    \end{columns}
\framebreak
%%%%%% Sorting
\begin{columns}[c,onlytextwidth]
 \column{.55\textwidth}
 \begin{itemize}
  \item Lexikographische Sortierung der Rotationen des Eingabestrings
 \end{itemize}
 \column{.45\textwidth}
    \begin{tabular}{c|c}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & aabrac \\
    1 & abraca \\
    2 & acaabr \\
    3 & bracaa \\
    4 & caabra \\
    5 & racaab \\
    \end{tabular}
\end{columns}
\framebreak
%%% Output of compression algorithm
\begin{columns}[c,onlytextwidth]
 \column{.55\textwidth}
 \begin{itemize}
  \item Resultat:\\
      Das Tupel \textit{$(L,I)$}, wobei L die {\color{red}letzte Spalte} der Matrix ist
      und I der Index des {\color{darkgreen}Eingabestrings in der Matrix} ist
  \item $(L,I) = (caraab, 1)$
 \end{itemize}
 \column{.45\textwidth}
    \begin{tabular}{T|T}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & aabra{\color{red}c} \\
    {\color{darkgreen}1} & {\color{darkgreen}abrac}{\color{red}a} \\
    2 & acaab{\color{red}r} \\
    3 & braca{\color{red}a} \\
    4 & caabr{\color{red}a} \\
    5 & racaa{\color{red}b} \\
    \end{tabular}
\end{columns}
\end{frame}
%%%%%% Decompression
\subsection{BWT -- Rücktransformation}
\begin{frame}[allowframebreaks]
\frametitle{BWT -- Rücktransformation}
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Eingabetupel: $(L,I)$
  \item Initialisierung einer Matrix M der Dimensionen $|L| \times |L|$
  \item Bereits bekannt: L ist die {\color{darkgreen}letzte Spalte} von M
 \end{itemize}
 \column{.35\textwidth}
    \begin{tabular}{c|c}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & \_\_\_\_\_{\color{darkgreen}c} \\
    1 & \_\_\_\_\_{\color{darkgreen}a} \\
    2 & \_\_\_\_\_{\color{darkgreen}r} \\
    3 & \_\_\_\_\_{\color{darkgreen}a} \\
    4 & \_\_\_\_\_{\color{darkgreen}a} \\
    5 & \_\_\_\_\_{\color{darkgreen}b} \\
    \end{tabular}
\end{columns}
\framebreak
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Die {\color{darkgreen}erste Spalte} ist immer sortiert
  \textrightarrow\ Kann durch sortieren von L ausgefüllt werden
 \end{itemize}
 \column{.35\textwidth}
    \begin{tabular}{T}
    \ttfamily{\color{darkgreen}a}\_\_\_\_c\\
    \ttfamily{\color{darkgreen}a}\_\_\_\_a\\
    \ttfamily{\color{darkgreen}a}\_\_\_\_r\\
    \ttfamily{\color{darkgreen}b}\_\_\_\_a\\
    \ttfamily{\color{darkgreen}c}\_\_\_\_a\\
    \ttfamily{\color{darkgreen}r}\_\_\_\_b\\
    \end{tabular}
\end{columns}
\framebreak
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Die {\color{darkgreen}erste Spalte} ist immer sortiert
  \textrightarrow\ Kann durch sortieren von $L$ ausgefüllt werden
 \end{itemize}

 \column{.35\textwidth}
    \begin{tabular}{c|l}
    \textbf{Row \#} & \textbf{Rotation} \\
    0 & {\color{darkgreen}a}\_\_\_\_c\\
    1 & {\color{darkgreen}a}\_\_\_\_a\\
    2 & {\color{darkgreen}a}\_\_\_\_r\\
    3 & {\color{darkgreen}b}\_\_\_\_a\\
    4 & {\color{darkgreen}c}\_\_\_\_a\\
    5 & {\color{darkgreen}r}\_\_\_\_b\\
    \end{tabular}
\end{columns}
\framebreak
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Die entstandene Matrix wird um ein Zeichen rotiert
 \end{itemize}
 \column{.35\textwidth}
 \begin{tabular}{T}
    \_\_\_\_c{\color{darkgreen}a}\\
    \_\_\_\_a{\color{darkgreen}a}\\
    \_\_\_\_r{\color{darkgreen}a}\\
    \_\_\_\_a{\color{darkgreen}b}\\
    \_\_\_\_a{\color{darkgreen}c}\\
    \_\_\_\_b{\color{darkgreen}r}
  \end{tabular}
\end{columns}
\framebreak
\begin{columns}[c,onlytextwidth]
 \column{.65\textwidth}
 \begin{itemize}
  \item Die Matrix wird lexikographisch sortiert
 \end{itemize}
 \column{.35\textwidth}
 \begin{tabular}{T}
    \_\_\_\_aa\\
    \_\_\_\_ab\\
    \_\_\_\_ac\\
    \_\_\_\_br\\
    \_\_\_\_ca\\
    \_\_\_\_ra
  \end{tabular}
\end{columns}
\framebreak
\begin{itemize}
 \item Die Schritte
 \begin{itemize}
  \item Schreiben von L in die rechteste freie Spalte
  \item Lexikographisches Sortieren
 \end{itemize}
 werden wiederholt bis die Matrix voll ist
\end{itemize}
%Demo frames
\framebreak
\begin{columns}
 \column{0.2\textwidth}
 \begin{tabular}{T}
    \_\_\_{\color{red}c}aa\\
    \_\_\_{\color{red}a}ab\\
    \_\_\_{\color{red}r}ac\\
    \_\_\_{\color{red}a}br\\
    \_\_\_{\color{red}a}ca\\
    \_\_\_{\color{red}b}ra
  \end{tabular}
 \column{0.1\textwidth}
 $\xrightarrow{\text{Sortieren}}$
 \column{0.4\textwidth}
 \begin{tabular}{T}
    \_\_\_aab\\
    \_\_\_abr\\
    \_\_\_aca\\
    \_\_\_bra\\
    \_\_\_caa\\
    \_\_\_rac
  \end{tabular}
\end{columns}
% Demo 2
\framebreak
\begin{columns}
 \column{0.2\textwidth}
 \begin{tabular}{T}
    \_\_{\color{red}c}aab\\
    \_\_{\color{red}a}abr\\
    \_\_{\color{red}r}aca\\
    \_\_{\color{red}a}bra\\
    \_\_{\color{red}a}caa\\
    \_\_{\color{red}b}rac
  \end{tabular}
 \column{0.1\textwidth}
 $\xrightarrow{\text{Sortieren}}$
 \column{0.4\textwidth}
 \begin{tabular}{T}
    \_\_aabr\\
    \_\_abra\\
    \_\_acaa\\
    \_\_brac\\
    \_\_caab\\
    \_\_raca
  \end{tabular}
\end{columns}
% Demo 3
\framebreak
\begin{columns}
 \column{0.2\textwidth}
 \begin{tabular}{T}
    \_{\color{red}c}aabr\\
    \_{\color{red}a}abra\\
    \_{\color{red}r}acaa\\
    \_{\color{red}a}brac\\
    \_{\color{red}a}caab\\
    \_{\color{red}b}raca
  \end{tabular}
 \column{0.1\textwidth}
 $\xrightarrow{\text{Sortieren}}$
 \column{0.4\textwidth}
 \begin{tabular}{T}
    \_aabra\\
    \_abrac\\
    \_acaab\\
    \_braca\\
    \_caabr\\
    \_racaa
  \end{tabular}
\end{columns}
% Demo 4
\framebreak
\begin{columns}
 \column{0.2\textwidth}
 \begin{tabular}{T}
    {\color{red}c}aabra\\
    {\color{red}a}abrac\\
    {\color{red}r}acaab\\
    {\color{red}a}braca\\
    {\color{red}a}caabr\\
    {\color{red}b}racaa
  \end{tabular}
 \column{0.1\textwidth}
 $\xrightarrow{\text{Sortieren}}$
 \column{0.4\textwidth}
 \begin{tabular}{T}
    aabrac\\
    abraca\\
    acaabr\\
    bracaa\\
    caabra\\
    racaab
  \end{tabular}
\end{columns}
\framebreak
\begin{columns}
\column{0.6\textwidth}
\begin{itemize}
 \item $M$ wurde vollständig rekonstruiert
 \item Zeile $I$ ist der {\color{red}Originaltext}
\end{itemize}
\column{0.4\textwidth}
\begin{tabular}{c|T}
    0 & aabrac \\
    {\color{red}1} & {\color{red}abraca}\\
    2 & acaabr \\
    3 & bracaa \\
    4 & caabra \\
    5 & racaab
\end{tabular}
\end{columns}
\end{frame}
%%%%%% Why it compresses well
\begin{frame}
 \frametitle{Komprimierbarkeit}
 \begin{itemize}
  \item Einige Zeichenkombinationen tauchen häufiger in Texten auf als andere, z.B. \textit{he} in \textit{the}
  \item Alle Zeilen von $M$ die mit \textit{he} beginnen tauchen nacheinander auf (Sortierung)
  \item Durch Rotation ist bei (fast) allen Zeilen die mit \textit{he} beginnen das letzte Zeichen \textit{t}
  \textrightarrow\ $L$ enthält viele aufeinanderfolgende Ts
 \end{itemize}
\end{frame}

%%%%%% Problems and solutions
\subsection{Probleme der BWT}
\begin{frame}
 \frametitle{Skalierbarkeit}
 \begin{itemize}
  \item Komplexität der BWT ist $\mathcal{O}(n^2)$\\
    \textrightarrow \ Anwendung der BWT auf sehr große Datensätze (z.B. Genome) skaliert nicht
    \pause
  \item Lösung: Unterteilung des Datensatzes in kleinere \textit{Blöcke} - Anwendung der BWT auf diese Blöcke
 \end{itemize}
\end{frame}
\begin{frame}
 \frametitle{Overhead}
 \begin{itemize}
  \item Die Länge des Tupels $(L,I)$ ist insgesamt größer als $|S|$
  \item Genauer Längenunterschied hängt von der Repräsentation von $(L,I)$ ab
  \item Lösung: Anwendung eines Kompressionsalgorithmus wie \textit{Deflate} auf $(L,I)$
  \end{itemize}
\end{frame}
%%%%%% Comp
\begin{frame}
 \frametitle{Vergleich mit anderen Algorithmen}
 \begin{columns}[c,onlytextwidth]
  \column{1\textwidth}
    \begin{itemize}
    \item Kompression ist meist ein Kompromiss zwischen Geschwindigkeit und Platzeinsparung
    \item Einige Algorithmen sind für spezielle Datentypen (z.B. Bilder) besser geeignet
    \item Einige Algorithmen (z.B. \textit{bzip2}) benutzen bereits die BWT\\
    \textrightarrow\ Kein Vergleich möglich
    \end{itemize}
  %\column{0.5\textwidth}
  %\begin{tabular}{c}
  %\textbf{Hohe Kompression}\\
  %\textuparrow \textbf{langsam}\\\hline
  %PAQ8\\
  %LZMA/LZMA2\\
  %bzip2\\
  %Deflate\\\hline
  %\textbf{Geringe Kompression}\\
  %\textuparrow \textbf{schnell}
  %\end{tabular}  
 \end{columns}
\end{frame}

\begin{frame}
 \frametitle{Resultate von Burrows und Wheeler}
 \includegraphics[width=\textwidth]{graph/bw-1.pdf}
\end{frame}

%%%%%% Results

%%%%%% Complexity
\begin{frame}
 \frametitle{Komplexität der BWT}
 \begin{itemize}
  \item Die Komplexität der BWT ist mindestens $\mathcal{O}(n^2)$
  % TODO 
 \end{itemize}
\end{frame}
\end{document}
